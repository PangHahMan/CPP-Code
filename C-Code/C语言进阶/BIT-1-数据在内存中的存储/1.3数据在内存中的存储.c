#include<stdio.h>
//整型类型的取值范围在limits.h中
//浮点数类型的取值范围在float.h中


//1.浮点数存储规则
/*
根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：
(-1) ^ S * M * 2 ^ E
(-1) ^ S表示符号位，当S = 0，V为正数；当S = 1，V为负数。
M表示有效数字，大于等于1，小于2。
2 ^ E表示指数位。

举例来说：
十进制的5.0，写成二进制是 101.0 ，相当于 1.01×2^2 。
那么，按照上面V的格式，可以得出S=0，M=1.01，E=2。
十进制的-5.0，写成二进制是 -101.0 ，相当于 -1.01×2^2 。那么，S=1，M=1.01，E=2。
*/
    

/*  如何存储？
IEEE 754对有效数字M和指数E，还有一些特别规定。
前面说过， 1≤M<2 ，也就是说，M可以写成 1.xxxxxx 的形式，其中xxxxxx表示小数部分。
IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分。
比如保存1.01的时候，只保存01，等到读取的时候，再把第一位的1加上去。这样做的目的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，
将第一位的1舍去以后，等于可以保存24位有效数字。
至于指数E，情况就比较复杂。首先，E为一个无符号整数（unsigned int）这意味着，如果E为8位，它的取值范围为0~255；
如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，
所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。
比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。
*/


//观察内存查看浮点数在内存中的存储形式
/*
int main()
{
	float f = 5.5;
	//(-1)^0*1.011*2^2
	//S=0 M=1.001 E-2
	//0 10000001（127+2）01100000000000000000000  存在内存中的二进制序列
	//E+127为修正值 防止出现负数
	//0100 0000 1011 0000 0000 0000 0000 0000
	//40 b0 00 00   16进制
	return 0;
}
*/


//如何取出
//指数E从内存中取出还可以再分成三种情况：
/*
・E不全为0或不全为1
这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。

・E全为0 (无穷小)
这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，
有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。

・E全为1 (无穷大)
这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；
*/


/*
int main()
{
	int n = 9;
	//00000000000000000000000000001001 - 9的二进制序列原码 补码 反码相同
	float* pFloat = (float*)&n;
	printf("n的值为：%d\n", n);   //9
	printf("*pFloat的值为：%f\n", *pFloat);   //0.000000
	//00000000000000000000000000001001
	//0 00000000  E为全0   无穷小

	*pFloat = 9.0;
	//9.0 浮点数
	//1001.0
	//1.001*2^3
	//(-1)^0*1.001*2^3
	//0 1000001 001000000000000000...  浮点数表示形式
	printf("num的值为：%d\n", n);   //以整型打出来浮点数直接以整型形式输出1091567616
	printf("*pFloat的值为：%f\n", *pFloat);
	return 0;
}
*/
