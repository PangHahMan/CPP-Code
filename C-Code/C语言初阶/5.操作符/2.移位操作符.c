#include<stdio.h>
//<< 左移操作符
//>> 右移操作符
//注：移位操作符的操作数只能是整数。 移位操作符，移动的是二进制
//二进制位的表示


//1.左移操作符
/*
移位规则：
左边抛弃、右边补0
int num = 10;
00000000000000000000000000001010   num在内存种的二进制  值为10
00000000000000000000000000010100   num左移一位产生的结果   值为20
左移操作符可以使原来的值扩大1倍(正数)  负数为缩小一倍
对负数进行移位。对补码移位->在回归原码，得移位后的结果
注：实际上num在没被赋值的情况下，自身的值不会变化
*/

/*
int main()
{
	int a = 4;
	//00000000000000000000000000000100  正数原码=补码
	int b = a << 1;  //a向左移动1位
	//00000000000000000000000000001000   变成8
	printf("a=%d b=%d", a, b);    //a=4  b=8
	return 0;
}
*/

/*
int main()
{
	int a = -4;
	//10000000000000000000000000000100  -4的原码
	//11111111111111111111111111111011  -4的反码
	//11111111111111111111111111111100  -4的补码
	int b = a << 1;  //a的补码向左移动1位
	//11111111111111111111111111111000   左移后的补码
	//11111111111111111111111111110111   -1得到反码
	//10000000000000000000000000001000   取反得到原码  结果为-8

	printf("a=%d b=%d", a, b);    //a=-4  b=-8
	return 0;
}
*/


//2.右移操作符
/*
移位规则：
首先右移运算分两种：(取决于编译器，大部分是算术移位VS)
1. 逻辑移位
左边用0填充，右边丢弃
2. 算术移位
左边用原该值的符号位填充，右边丢弃

int num = -1;
11111111111111111111111111111111   内存中存储-1的补码为32个全1
算术移位
11111111111111111111111111111111   右移后左边补符号位，所以算术右移后不变
逻辑移位
01111111111111111111111111111111   左边用0填充，值变成正数
☆右移操作符可以使原来的值缩小一倍(正数) 负数为扩大一倍
*/

//对于移位运算符，不要移动负数位，这个是标准未定义的。 
/*
int num = 10;
num>>-1;    //error  非法的
*/

/*
int main()
{
	int a = -4;
	//10000000000000000000000000000100  -4的原码
	//11111111111111111111111111111011  -4的反码
	//11111111111111111111111111111100  -4的补码
	int b = a >> 1;  //a的补码向右移动1位
	//11111111111111111111111111111100
	//01111111111111111111111111111110   逻辑右移
	//11111111111111111111111111111110   算术右移
	//11111111111111111111111111111101   -1得到反码
	//10000000000000000000000000000010   取反得原码  为-2


	printf("a=%d b=%d", a, b);    //a=-4  b=-2
	return 0;
}
*/

/*
int main()
{
	int a = 4;
	//00000000000000000000000000000100  正数原码=补码
	int b = a >> 1;  //a向左移动1位
	//00000000000000000000000000000010   变成2
	printf("a=%d b=%d", a, b);    //a=4  b=2
	return 0;
}
*/
