#include<stdio.h>
//表达式求值的顺序一部分是由操作符的优先级和结合性决定。
//同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。

//1.隐式类型转换(整型提升)
/*
C的整型算术运算总是至少以缺省整型类型的精度来进行的。
为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型
提升。
*/


//整型提升的意义：
/*
表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度一般就是int的字节长度，
同时也是CPU的通用寄存器的长度。
因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
通用CPU（general-purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。
☆所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。
*/

//如何进行整体提升呢？  整形提升是按照变量的数据类型的符号位来提升的
/*
//负数的整形提升
char c1 = -1;
变量c1的二进制位(补码)中只有8个比特位：
1111111
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为1
提升之后的结果是：
11111111111111111111111111111111
//正数的整形提升
char c2 = 1;
变量c2的二进制位(补码)中只有8个比特位：
00000001
因为 char 为有符号的 char
所以整形提升的时候，高位补充符号位，即为0
提升之后的结果是：
00000000000000000000000000000001
//无符号整形提升，高位补0
*/


/*
int main()
{
	char a = 5;       //00000101
	char b = 126;     //01111110
	char c = a + b;
	//00000000000000000000000000000101
	//截断00000101
	//00000000000000000000000001111110
	//截断01111110

	//a+b  整型提升(按符号位提升)
	//00000000000000000000000000000101  a
	//00000000000000000000000001111110  b
	//00000000000000000000000010000011  c
	//c截断 10000011
	printf("%d\n", c);    //-125
	//%d十进制的方式打印有符号整数
	//10000011整型提升
	//11111111111111111111111110000011  补码
	//11111111111111111111111110000010  -1
	//10000000000000000000000001111101  -125
	return 0;
}
*/


/*
int main()
{
	char a = 0xb6;   //10110110
	short b = 0xb600;
	int c = 0xb6000000;
	if (a == 0xb6)   //a发生了整型提升
		printf("a");
	if (b == 0xb600)   //b发生了整型提升
		printf("b");
	if (c == 0xb6000000)
		printf("c");  //只有c打印
	return 0;
}
实例1中的a,b要进行整形提升,但是c不需要整形提升
a,b整形提升之后,变成了负数,所以表达式 a==0xb6 , b==0xb600 的结果是假,但是c不发生整形提升,则表
达式 c==0xb6000000 的结果是真.
所程序输出的结果是:c
*/


/*
int main()
{
	char c = 1;
	printf("%zu\n", sizeof(c));
	printf("%zu\n", sizeof(c+1));
	printf("%zu\n", sizeof(+c));
	printf("%zu\n", sizeof(-c));
	return 0;
}
实例2中的, c只要参与表达式运算, 就会发生整形提升, 表达式 + c, 就会发生提升, 所以 sizeof(+c) 是4个字
节.
表达式 - c 也会发生整形提升, 所以 sizeof(-c) 是4个字节, 但是 sizeof(c), 就是1个字节.
*/


//2.算术转换
/*
如果某个操作符的各个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类
型，否则操作就无法进行。下面的层次体系称为寻常算术转换。
long double
double
float
unsigned long int
long int
unsigned int
int

如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运
算。
警告：
但是算术转换要合理，要不然会有一些潜在的问题。

float f = 3.14;
int num = f;//隐式转换，会有精度丢失

*/


//3.操作符的属性
/*
复杂表达式的求值有三个影响的因素。
1. 操作符的优先级
2. 操作符的结合性
3. 是否控制求值顺序。
两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。
操作符优先级
*/


//一些问题表达式
//表达式的求值部分由操作符的优先级决定。

//表达式1
// a* b + c * d + e * f   
//注释：代码1在计算的时候，由于* 比 + 的优先级高，只能保证， * 的计算是比 + 早，但是优先级并不
//能决定第三个 * 比第一个 + 早执行。


//表达式2
// c + --c;
//注释：同上，操作符的优先级只能决定自减--的运算在 + 的运算的前面，但是我们并没有办法得
//知， + 操作符的左操作数的获取在右操作数之前还是之后求值，所以结果是不可预测的，是有歧义
//的。


//代码3-非法表达式
/*
int main()
{
	int i = 10;
	i = i-- - --i * (i = -3) * i++ + ++i;
	printf("i = %d\n", i);
	return 0;
}
*/
//表达式3在不同编译器中可以测试不同的结果


//代码4
/*
int fun()
{
	static int count = 1;
	return ++count;
}
int main()
{
	int answer;
	answer = fun() - fun() * fun();
	printf("%d\n", answer);//输出多少？
	return 0;
}
*/
/*
这个代码有没有实际的问题？
有问题！
虽然在大多数的编译器上求得结果都是相同的。
但是上述代码 answer = fun() - fun() * fun(); 中我们只能通过操作符的优先级得知：先算乘法，
再算减法。
函数的调用先后顺序无法通过操作符的优先级确定。
*/


//代码5
/*
int main()
{
	int i = 1;
	int ret = (++i) + (++i) + (++i);
	printf("%d\n", ret);
	printf("%d\n", i);
	return 0;
}
不同编译器结果不同*/   

//我们写出的表达式如果不能通过操作符的属性确定唯一的计算路径，那这个表达式就是存在问题的。